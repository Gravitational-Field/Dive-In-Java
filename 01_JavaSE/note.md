[TOC]

---

# 1. 语法基础

## 1.1 数据类型

​	在Java语言中将数据类型分为以下两大类：

  ### 1.1.1 基本数据类型

​         byte、short、int、long、float、double、boolean、char
​          1个   2个   4个   8个   4个     8个      1个    2个

  在Java语言中用于描述整数数据的类型有：byte、short、int、long，推荐使用int类型
   其中byte类型在内存空间中占1个字节，表示的范围是：-2^7 ~ 2^7-1.
                                                    -128 ~ 127.
   其中short类型在内存空间中占2个字节，表示的范围是：-2^15 ~ 2^15-1.
                                                    -32768 ~ 32767.
   其中int类型在内存空间中占4个字节，表示的范围是：-2^31 ~ 2^31-1.
                                                    正负二十一亿之间.
   其中long类型在内存空间中占8个字节，表示的范围是：-2^63 ~ 2^63-1.
                                                    比int类型还大的数.

   其中float类型在内存空间中占4个字节，叫做单精度浮点数，通常可以有效到小数点后7位
   其中double类型在内存空间占8个字节，叫做双精度浮点数，通常可以有效到小数点后15位

PS：由于float类型和double类型都不能实现精确运算，因此在以后的商业开发中可能需要借助java.math.BigDecimal类型加以描述。

   在Java语言中用于描述真假信息的类型有：boolean，数值只有：true(真) 和 false(假)
   其中boolean类型在内存空间的大小没有明确的规定，通常认为占1个字节。

 字符类型
   在Java语言中用于描述单个字符的数据类型是：char，如：'a'  '1'  '中'等         
   其中char类型在内存空间中占2个字节，在以后的开发中很少使用该类型，而是使用String类型来描述多个字符组成的字符串，如"xiaomage"等
   由于计算机的底层只识别0和1组成的二进制序列，为了使得'a'这样的图案能够存储到计算机中就需要给该图案指定编号，这种编号叫做ASCII，要求大家记住的ASCII有：
      'a' - 97    'A' - 65   '0' - 48     空格 - 32   换行 - 10   
   要求大家记住的转义字符有：
       \" - "   \' - '   \\ - \   \n - 换行   \t - 制表符

![image-20200728090134239](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728090134.png)

### 1.1.2 引用数据类型
​         数组、类、接口、枚举、注解

- 数组

  - 一维数组

    ```
    1.1 基本概念
       当需要在程序中记录单个数据内容时，则应该声明一个变量即可；
       当需要在程序中记录多个类型相同的数据内容时，则应该声明一个一维数组，一维数组本质上就是内存中一段连续的存储单元。
    如：
       int score = 59; 
       int score2 = 60;
       ...
    
    1.2 数组的声明
    (1)语法格式
       数据类型[] 数组名称 = new 数据类型[数组的长度];
    如：
       int[] arr = new int[3];  - 表示声明一个长度为3元素类型为int类型的一维数组
       int num = 3;             - 表示声明一个初始值为3元素类型为int类型的变量
       int arr[] = new int[3];  - 不推荐使用         	   
    
    注意事项：
       只有在声明数组时[]中的数字才表示数组的长度，否则一律代表数组的下标。
    
    (2)元素的初始化
       数据类型[] 数组名称 = {元素值1, 元素值2, ...};
    如：
       int[] arr = {1, 2, 3}; - 表示声明一个长度为3元素初始值为1,2,3的一维数组
    ```

    测试： int[] arr;    之后arr能放下其它数么？还是能接收个引用？

  

  - 二维数组

      ```
      2.1 基本概念
      一维数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据内容。
      二维数组本质上就是由多个一维数组组成的数组，也就是说二维数组中的每个元素都是一维数组，而一维数组的每个元素才是具体的数据内容。

      2.2 声明方式
      (1)语法格式
      数据类型[][] 数组名称 = new 数据类型[行数][列数];
      如：
      int[][] arr = new int[2][3]; - 表示声明一个具有2行3列元素类型为int类型的二维数组
      其中行下标为：0 ~ 1；
      其中列下标为：0 ~ 2；

      (2)元素的初始化
      数据类型[][] 数组名称 = {{元素值1, 元素值2, ...}, {元素值3, 元素值4, ...}, ...};
      如：
      int[][] arr = {{1, 2, 3}, {4, 5, 6}}; - 表示声明一个2行3列的二维数组
      ```

- 数组理解：

  - 一维数组初始状态：

    ![image-20200728100245937](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100245.png)

  - 一维数组的概念:

    ![image-20200728100356425](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100356.png)

  - 一维数组的赋值操作

    ![image-20200728100440658](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100440.png)

  - 一维数组的插入操作

  ![image-20200728100532137](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100532.png)

  - 一维数组的删除操作

  ![image-20200728100605219](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100605.png)

  - 一维数组的查改操作

  ![image-20200728100646346](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100646.png)

  - 二维数组的基本概念

  ![image-20200728100729429](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728100729.png)

## 1.2 运算符

### 1.2.1 算术运算符

```
\+ 表示加法运算符      -  表示减法运算
\* 表示乘法运算符      /  表示除法运算符
% 表示取模/取余运算符
```

注意事项：
   (1)当两个整数相除时，则结果只取整数部分丢弃小数部分。
   (2)若希望保留小数部分，处理方式如下：
        a.将其中一个操作数强制转换为double类型之后再运算；
        b.使用其中一个操作数乘以1.0之后再运算；
   (3)0不能做除数，0.0可以做除数，但都不推荐使用；
   (4)+既可以作为加法运算符也可以作为字符串连接符，区分方式如下：
      只要+两端的操作数中有1个操作数是字符串，则按照连接符处理，连接结果还是字符串

### 1.2.2 关系/比较运算符
    <  表示是否小于运算符          <= 表示是否小于等于运算符
    >  表示是否大于运算符          >= 表示是否大于等于运算符
    == 表示是否等于运算符          != 表示是否不等于运算符

所有以关系运算符为最终运算的表达式结果一定是boolean类型。

### 1.2.3 自增减运算符

```
+ 表示加法运算符        ++ 表示自增运算符

- 表示减法运算符        -- 表示自减运算符
```

注意：
   a.对于单个变量来说，++无论出现在变量的前面还是后面从结果上来说都是等价的；
   b.ia++ 叫做后++，表示先让ia的数值作为整个表达式的结果，然后再让ia进行加1的操作；
     ++ia 叫做前++，表示先让ia的数值进行加1操作，然后再让ia的数值作为表达式的结果；

### 1.2.4  逻辑运算符

```
 && 表示逻辑与运算符，相当于"并且"，同真为真，一假为假。
 || 表示逻辑或运算符，相当于"或者"，一真为真，同假为假。
  !  表示逻辑非运算符，相当于"取反"，真为假，假为真。
```

短路特性：
   对于逻辑与运算符来说，若第一个操作数结果为假则整个表达式一定为假，此时跳过第二个操作数的判断；
   对于逻辑或运算符来说，若第一个操作数结果为真则整个表达式一定为真，此时跳过第二个操作数的判断；   

### 1.2.5 位运算符

```
& 表示按位与运算符，按照二进制位进行与运算，同1为1,一0为0(1-真  0-假)；
| 表示按位或运算符，按照二进制位进行或运算，一1为1,同0为0；
~ 表示按位取反运算符，按照二进制位进行取反运算，1为0，0为1；
^ 表示按位异或运算符，按照二进制位进行异或运算，相同为0，不同为1；
<<  表示左移运算符，按照二进制位向左移动，右边使用0补充；
>>  表示右移运算符，按照二进制位向右移动，左边使用符号位补充；
>>> 表示无符号右移运算符，按照二进制位向右移动，左边使用0补充；
```

### 1.2.6 三目运算符

```
条件表达式 ? 语句1 : 语句2   
	=> 判断条件表达式是否成立
        => 若成立，则执行语句1;
        => 若不成立，则执行语句2;
```

### 1.2.7 赋值运算符

```
简单赋值:
	= 表示赋值运算符，用于将=右边的数据赋值给=左边的变量来覆盖该变量原来的数值。
	10 == ia; 用于判断10是否等于ia的数值
	ia = 10;  用于将数据10赋值给变量ia
复合赋值
   +=  -=  *=  /=
   int ia = 3;
   ia = ia + 2;  => ia += 2; 
```

### 1.2.8 运算符优先级

```
(1) ()的优先级极高，通常最先计算；
(2) =的优先级极低，通常最后计算；
(3) * / % 的优先级高于 + -，同级时从左向右计算；
```

![image-20200728092712363](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728092712.png)

## 1.3 语法结构

### 1.3.1 顺序结构

```
按照逻辑从上到下。
```

### 1.3.2 分支结构

- ```
  if分支结构:
  (1)语法格式
     if(条件表达式){
        语句块;
     }
  
  (2)执行流程
     判断条件表达式是否成立
         => 若成立，则执行语句块；
         => 若不成立，则跳过语句块；
  ```

- ```
  if-else分支结构:
  (1)语法格式
     if(条件表达式){
        语句块1;
     }
     else{
        语句块2;
     }
  
  (2)执行流程
     判断条件表达式是否成立
         => 若成立，则执行语句块1；
         => 若不成立，则执行语句块2；
  ```

- ```
  if-else if-else分支结构:
  (1)语法格式
     if(条件表达式1){
        语句块1;
     } 
     else if(条件表达式2){
        语句块2;
     }
     ...
     else{
         语句块n;
     }
  
  (2)执行流程
     判断条件表达式1是否成立
         => 若成立，则执行语句块1
         => 若不成立，则判断条件表达式2是否成立
                 => 若成立，则执行语句块2
                 => 若不成立，则执行语句块n
  ```


- ```
  switch-case分支结构
  (1)语法格式
     switch(变量/表达式){
        case 字面值1: 语句块1; break;
        case 字面值2: 语句块2; break;
        ...
        default:语句块n;
     } 
  
  (2)执行流程  
     计算变量/表达式的数值 => 判断是否匹配字面值1
         => 若匹配，则执行语句块1 => 执行break跳出当前结构
         => 若不匹配，则判断是否匹配字面值2
                 => 若匹配，则执行语句块2 => 执行break跳出当前结构
                 => 若不匹配，则执行语句块n
  
  (3)注意事项
     switch()中支持byte、short、char以及int类型，从jdk1.5开始支持枚举类型，从jdk1.7开始支持String类型。
  ```

  练习：
     提示用户输入考试的成绩，使用if-else if-else分支结构判断所在等级并打印(不合理成绩暂时不考虑)。
        [90 ~ 100]   等级A     /10     9  10  
        [80 ~ 89]    等级B     /10     8  
        [70 ~ 79]    等级C     /10     7
        [60 ~ 69]    等级D     /10     6
        [0 ~ 59]     等级E     default:

### 1.3.3 循环结构

- ```
  for循环：
  (1)语法格式
     for(初始化表达式; 条件表达式; 修改初始值表达式){
        循环体;
     }
  
  (2)执行流程   
     执行初始化表达式 => 判断条件表达式是否成立
         => 若成立，则执行循环体 => 执行修改初始值表达式 => 判断条件表达式是否成立
         => 若不成立，则循环结束
  
  ```

练习：

- 求用户输入四个整数中的最大值并打印（参考PPT）。

- 使用for循环打印1 ~ 100之间的所有奇数（参考PPT）。 

- 使用for循环计算1 ~ 10000之间的累加和并打印（参考PPT）。    

- 使用for循环打印三位数中的所有水仙花数(参考PPT)。

- 正整数的逆序输出。

- ```
    使用双重for循环打印以下图形：
        *
        **
        ***
        ****
        *****
        
    进阶版为：打印一个菱形，
    
    
    再进阶版为打印一个内空的菱形，并封装。
  ```

- 打印99乘法表
- 冒泡排序



# 2. 面向对象编程

## 2.1 类、对象及引用

### 2.1.1 类

```
基本概念
   类就是"分类"的含义，用于作为多个对象共性的抽象描述，是创建对象的模板(图纸)。
   在Java语言中类是一种引用数据类型，里面包含用于描述特征的成员变量以及用于描述行为的成员方法共同组成。
   对象是客观存在的实体(楼)，在Java语言中体现为堆区的一块内存区域。   

类的定义
(1)类定义的语法格式
   class 类名{
      类体;
   }   
如：
   class Person{
   }
注意：
   当类名由多个单词组成时，要求每个单词的首字母都要大写。
     
(2)成员变量定义的语法格式
   class 类名{
       数据类型 成员变量名 = 初始值;   // 其中 =初始值 通常都省略，但分号不可以省略 
   }
如：
   class Person{
       String name;
       int age;
   } 
注意：
   当成员变量名由多个单词组成时，要求从第二个单词起每个单词的首字母大写。
扩展：
   成员变量 : 主要指声明在类体内、方法体外的变量，作用域从声明开始到类体结束。
   局部变量 : 主要指声明在方法体内部的变量，作用域从声明开始到方法体结束。
```

### 2.1.2 对象

```
对象的创建
(1)语法格式
   new 类名();
如：
   new Person();  - 表示创建Person类型的对象

(2)注意事项
   a.使用new关键字创建/构造对象的过程，叫做类的实例化。
   b.创建对象的本质就是在堆区申请一块存储区域，用于存放该对象独有的成员变量信息。
```

### 2.1.3 引用

```
(1)基本概念
   使用引用数据类型声明的变量叫做引用型变量，简称为"引用"。
   引用主要用于记录对象在堆区中的内存地址信息便于下次访问。

(2)语法格式
   类名 引用变量名;
如：
   Person p;  - 表示声明Person类型的引用变量p
   Person p = new Person(); - 声明Person类型的引用p指向Person类型的对象

   访问对象中成员变量的方式：
       引用.成员变量名;
   如：
       p.name = "zhangfei";
       p.age = 30;
```



## 2.2 成员方法

### 2.2.1 语法格式

```
   class 类名{
       返回值类型 成员方法名(形参列表){
           成员方法体;
       }
   }
如：
   class Person{
       void show(){
           System.out.println("没事出来秀一下！");
       }
   }
注意：
   当成员变量名由多个单词组成时，要求从第二个单词起每个单词的首字母大写。
```

### 2.2.2 方法的详解
```
(1)返回值类型
   返回值主要指从方法体内向方法体外返回的数据内容。
   返回值类型主要指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型。
   如：
      当返回的数据内容是66时，则返回值类型写 int 类型即可；
      当返回的数据内容是3.14时，则返回值类型写double类型即可；
      当返回的数据内容是"hello"时，则返回值类型写String类型即可；
   在方法体中使用return关键字用于返回数据内容并结束当前方法。
   如：
      当返回的数据内容是66时，则方法体中写：return 66;
      当返回的数据内容是3.14时，则方法体中写：return 3.14;
   当该方法不需要返回任何数据内容时，则返回值类型写void即可。

(2)形参列表
   形式参数主要指从方法体外向方法体内传入的数据内容，格式为：数据类型 形参变量名。
   形参列表指多个形式参数，格式为：数据类型 形参变量名1, 数据类型 形参变量名2, ...
   如：
      当传入的数据内容是66时，则形参列表写为：int i;
      当传入的数据内容是3.14时，则形参列表写为：double d;
      当传入的数据内容是"hello"时，则形参列表写为：String s;
      当传入的数据内容是66和3.14时，则形参列表写为：int i, double d;
      当传入的数据内容是66和"hello"时，则形参列表写为：int i, String s;
   当该方法不需要传入任何数据内容时，则形参列表啥也不写即可；

(3)成员方法体
   成员方法体中主要编写描述该方法功能的语句块；   
```

### 2.2.3 方法的调用
```
(1)语法格式
   引用.成员方法名(实参列表);
如：
   p.show();  //表示调用p对应Person类型中的show方法，实参啥也没有传递

(2)注意事项
   a.实际参数列表主要用于对形式参数列表进行初始化工作，因此类型、个数、顺序等
     都必须保持一致。
   b.实际参数列表可以传递字面值、变量、表达式以及方法的调用等。
```

### 2.2.4 方法的传参

```
方法的传参过程：
  (1)main方法是程序的入口，先为main方法的局部变量申请内存空间并初始化；
  (2)调用max方法时，为max方法的形参变量申请内存空间；
  (3)使用实参变量的数值给形参变量进行初始化；
  (4)执行max方法的方法体，执行完毕后释放形参变量的内存空间；
  (5)main方法中res得到max方法的返回值继续向下执行；
  
 a.当基本数据类型作为方法的参数传递时，通常形参变量的改变不会影响到实参变量；
 b.当引用数据类型作为方法的参数传递时，通常形参变量指向内容的改变会影响到实参变量指向的内容，因为两个变量共享同一块堆区空间；
 c.当引用数据类型作为方法的参数传递时，若形参变量改变指向后再改变指向的内容时，不会对实参变量指向的内容有影响，因为两个变量各自拥有一块独立的堆区空间；
```

测试：参数传递。

### 2.2.5 方法的递归调用

```
基本概念
   递归主要指在方法体的内部调用当前方法自身的形式。
使用方式
  (1)使用递归必须找到规律以及退出条件；
  (2)使用递归必须使得问题简单化而不是复杂化；
  (3)若递归影响到程序的执行性能，则应该使用递推替代之；
```

```java
// 斐波那切数列递推与递归实现
int fib(int n){
    int fn   = 1;
    int fn_1 = 0;
    for(int i=0; i<n; i++) {
       int t = fn
       fn    = fn + fn_1;
       fn_1  = t;
    }
    return fn;
}

int fib(n){
    return n < 2 ? 1 : fib(n-1)+f(n-2);
}
```

练习：自定义成员方法计算参数n指定整数的阶乘并返回。

**需要进一步去leetcode去训练。**

- 费氏数列的递归分析

![image-20200728142241325](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728142241.png)

- 费氏数列的递推分析

![image-20200728142326684](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728142326.png)

## 2.3 构造方法与方法重载

```
如：
   Person p = new Person();  - 表示声明Person类型的引用p指向Person类型的对象
   p.show();                 - 表示调用名字为show的成员方法
```

### 2.3.1 构造方法

```
(1)构造方法语法格式
   class 类名{
      类名(形参列表){
          构造方法体;
      } 
   }
如：
   class Person{
      Person(){
         System.out.println("无参构造方法！");
      }
   }

(2)注意事项
   a.构造方法的名称与类名相同，并且没有返回值类型连void都不许有。
   b.当使用new关键字构造对象时，会自动调用构造方法实现成员变量的初始化工作。

(3)默认构造方法
   当一个类的定义中没有出现任何形式的构造方法时，编译器会自动添加无参的空构造方法，叫做默认/缺省构造方法，如：Person(){}.
   若类中出现了自定义构造方法，则编译器不再提供任何构造方法。

```

- 程序执行流程与内存分析

![image-20200728105436159](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728105436.png)

### 2.3.2 方法的重载

```
(1)基本概念
   	在Java语言中若方法名相同但参数列表不同，这样的方法之间构成重载关系(Overload)。

(2)体现形式
   	方法重载的体现形式为：参数的个数不同、参数的类型不同以及参数的顺序不同，与参数变量名和返回值类型无关，但建议返回值类型最好相同。
   	判断方法能否重载的核心：调用方法时能否加以区分。
(3)重载的意义：
	方法重载的意义在于调用者只需要记住一个方法名就可以调用各种不同的版本从而带来各种不同的效果。
    如：
       int i = 10;
       System.out.println(i);
       double d = 3.14;
       System.out.println(d);
       boolean b = true;
       System.out.println(b);
```

## 2.4 this关键字

```
this基本概念
   若在构造方法中出现了this关键字，则代表当前正在构造的对象；
   若在成员方法中出现了this关键字，则代表当前正在调用的对象；

原理分析：
   当成员方法中访问成员变量时会默认加上this.，this.相当于汉语中"我的"，因此不同的对象调用同一个方法时会导致this关键字不同，那么this.访问成员变量的结果随之不同。

使用方式
  (1)当形参变量名与成员变量名同名时，在方法体中会优先使用形参变量，若希望使用成员
     变量则需要在变量名的前面加上this.加以说明(掌握)。
  (2)在构造方法的第一行使用this(实参)的方式可以调用本类中的其它构造方法(了解)。
```

## 2.5 封装

```
基本概念
   语法上可以给成员变量赋值一些符合语法但不合理的数值，这种情况在编译阶段和运行阶段都不会报错或给出任何的提示信息，此数值虽然合法但与现实生活不符；
   为了避免上述问题的发生，就需要对成员变量进行密封包装处理来保证该成员变量的合法合理性，这种机制就叫做封装。
实现流程
  (1)私有化成员变量，使用private关键字修饰；
  (2)提供公有的get和set方法，在方法体中进行合理值的判断，使用public关键字修饰；
  (3)在构造方法中使用set方法进行合理值的判断；
```

练习



## 2.6 static关键字

```
基本概念:
	通常情况下成员变量隶属于对象层级，也就是每当创建一个对象就会拥有独立的内存空间来存放独立的成员变量信息，若所有对象中某个成员变量完全相同时还要各自存储，则会造成内存空间的浪费。
   	为了解决上述问题则使用static关键字修饰该成员变量表达静态的含义，此时该成员变量由对象层级提升为类层级只有一份并被所有对象共享，会随着类的加载而准备就绪与是否创建对象无关。
   	static关键字既能修饰成员变量也能修饰成员方法，推荐使用 类名. 的方式访问。

使用方式:
    (1)非静态的成员方法中既能访问非静态的成员又能访问静态的成员。
       (成员：成员变量 + 成员方法  静态成员被所有对象共享)
    (2)静态的成员方法中只能访问静态的成员不能访问非静态的成员。
       (成员：成员变量 + 成员方法  调用该方法时可能还没有创建对象)
    (3)只有隶属于类层级被所有对象共享的内容才可以使用static关键字修饰。
       (不能滥用static关键字)
```

![image-20200728131127628](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728131127.png)

## 2.7 单例模式实现

```
(1)基本概念
   当一个类对外提供且只提供一个对象时，这样的类叫做单例类。
   而设计单例类的思想和编程模式叫做 单例设计模式。

(2)实现流程
   a.私有化构造方法，使用private关键字修饰；
   b.提供本类类型的引用指向本类的对象，使用private static关键字共同修饰；
   c.提供公有的get方法负责将对象返回出去，使用static关键字修饰；

(3)实现方式
   单例设计模式分为两种：饿汉式 和 懒汉式，在以后的开发中推荐饿汉式。
```

![image-20200728131159089](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728131159.png)



练习：构建一个单例类

如何能提供且仅能提供有限个对象？

## 2.8 继承

```
基本概念
   当多个类之间有相同的特征和行为时，可以将共性的内容提取出来组成一个公共类，让多个类分别吸收公共类中已有的特征和行为，而在多个类中只需要编写自己独有特征和行为的机制就叫做继承。  
   使用继承可以提高代码的复用性、可维护性以及可扩展性。
   在Java语言中使用extends(扩展)关键字来表达继承关系。
如：
   public class Student extends Person{}  - 表示Student类继承自Person类
   其中Person类叫做超类、基类、父类。
   其中Student类叫做派生类、孩子类、子类。

注意事项
  (1)子类可以继承父类的成员变量，包括私有成员变量但不能直接访问；
     子类不可以继承父类的构造方法和私有成员方法；
```

## 2.9 super关键字

```
(1)基本概念
   this关键字主要代表本类的对象；
   super关键字主要代表父类的对象；

(2)使用方式
   使用this.的方式可以访问本类的成员变量和成员方法；
   使用super.的方式可以访问父类的成员变量和成员方法；
 
   使用this()在构造方法的第一行表示调用本类中的其他构造方法；
   使用super()在构造方法的第一行表示调用父类的构造方法；

要求大家掌握的用法：
   a.使用this.的方式可以区分同名的成员变量和形参变量；
   b.使用super(实参)的方式可以调用父类的构造方法；
   c.使用super.的方式可以可以调用父类中被重写的方法；
```

## 2.10 方法的重写(Override)

```
(1)基本概念
   当子类从父类类继承的方法不足以满足子类的需求时，就需要在子类中重新写一个与父类一样的方法来覆盖从父类继承的版本，这个过程叫做方法的重写。

(2)重写的原则(笔试题)
   a.要求方法名相同、参数列表相同以及返回值类型相同，从jdk1.5开始允许返回子类类型；
   b.要求方法的访问权限不能变小，可以相同或者变大；
   c.要求不能抛出更大的异常(异常机制)；
```

## 2.11 访问控制

```
(1)常用的访问控制符(笔试题)
   访问控制符    访问权限     本类         本包中的类    子类      其它包中的其它类
----------------------------------------------------------------------------------
    public       公有的        ok         ok         ok             ok
    protected    保护的        ok         ok         ok             no
啥也不写default    默认的        ok         ok         no             no
    private      私有的        ok         no         no             no

要求大家掌握的内容：
    a.public修饰的内容可以在任意位置使用；
    b.private修饰的内容只能在本类中使用；
    c.通常情况下，成员方法都使用public修饰，成员变量都使用private修饰；
(2)包的定义
    package 包名;    
    package 包名1.包名2...包名; - 主要用于定义多层包，为了便于管理和避免命名冲突.
```



## 2.12 final关键字

```
(1)基本概念
   final本意为"最终的，不可更改的"，可以修饰类、成员方法、成员变量；

(2)使用方式
   使用final关键字修饰类，体现在该类不能被继承。
       - 为了防止滥用继承，如：java.lang.String类等。
   使用final关键字修饰成员方法体现在该方法不能被重写。
       - 为了防止不经意间造成的重写，如：java.text.DateFormat类等。
   使用final关键字修饰成员变量体现在该变量必须初始化而且不能更改。
       - 为了防止不经意间修改数值，如：java.lang.Thread类的MAX_PRIORITY等。
```

```
扩展：
   在以后的开发中很少单独使用static关键字或final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量来表达常量的含义，常量的命名规范是：所有字母大写，不同单词之间采用下划线连接，如：
   public static final double PI = 3.1415926;
```



## 2.13 对象创建的过程

```
(1)单个对象创建的执行过程:
    (1)main方法是程序的入口，当创建对象时会在堆区申请一块存储区域；
    (2)若没有指定成员变量的初始值时，则采用默认初始化进行；
    (3)若指定成员变量的初始值后，则采用显式初始化进行；
    (4)执行构造块可以对成员变量进行赋值；
    (5)执行构造方法体可以对成员变量进行再次赋值；
    (6)此时对象创建完毕，继续向下执行；

(2)子类对象创建的执行过程:
    (1)main方法是程序的入口；
    (2)先加载父类再加载子类，因此先执行父类的静态代码块，再执行子类的静态代码块；
    (3)执行父类的构造块和父类的构造方法体，此时父类部分构造完毕；
    (4)执行子类的构造块和子类的构造方法体，此时子类对象构造完毕；
    (5)继续执行后续的代码；
```



![image-20200728141245404](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728141245.png)



## 2.14 多态 day10

```
(1)基本概念
   多态主要指同一种事物表现出来的多种形态。
   人：学生、教师、工人、... 
   饮料：可乐、雪碧、红牛、乐虎、...
   动物：猫、狗、鸟、小强、...  
   整数：byte b1 = 10; short s1 = 10; int i1 = 10; ...   
   ... 

(2)语法格式
   父类类型 引用变量名 = new 子类类型();
如：
   Animal ad = new Dog();
   ad.show();
解析：
   编译阶段调用父类的show方法，运行阶段调用子类重写以后的show方法。

(3)多态的效果
    (1)当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有(子类中没有)的方法；
    (2)当父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法；    //如父类中无show()，而子类中有show();  父类的引用无法调用子类的show()？？？验证
    (3)对于父子类都拥有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类版本    //只有这种情况下，父类指向子类的引用才可以调用子类的show()方法
    (4)对于父子类都拥有的静态方法来说，编译和运行阶段都调用父类版本，与对象无关；
```

练习：

​	 自定义矩形(Rect)类，特征有：横纵坐标、长度及宽度，要求实现封装并提供打印方法；
​     自定义圆形(Circle)类，特征有：横纵坐标、半径，要求实现封装并提供打印方法；
​     提取共性自定义图形(Shape)类。
​     自定义TestShape类，自定义成员方法实现既能打印矩形又能打印圆形的方法并调用。

## 2.15 instanceof关键字

```
(1)基本概念
	判断对象是否来自某个指定的类，(只能是引用类型，不能是基本类型)
		是==>返回true
		否==>返回false
(2)使用
	instancceof 常用于解决ClassCastException 
```

## 2.16 抽象类

```
在Java中, 使用abstract关键字 修饰的类, 称为抽象类 ! 
抽象类不能实例化 !  抽象类如果不被继承 , 则没有意义 !  
抽象类中 非抽象的部分 是抽取出的公共部分 !
抽象类中, 抽象的方法可以被子类重写,  我们称这种操作叫做抽象方法的 实现 !
```

- 面试题

```
一个类, 如果没有抽象方法, 可以不可以被定义为 抽象类 ? 如果可以, 有什么意义 !
答:  可以定义为抽象类, 它的意义在于不让程序创建本类对象 !

抽象关键字 abstract 与哪些关键字 不能共存: 
答:
    private :   私有的方法,  子类无法重写 ! 
    final   :   final修饰的方法,   不能被重写!
    static  :   静态的方法, 不依赖于对象! 
```

## 2.17 模板方法设计模式  day11

```
定义一个功能的骨架 , 一部分功能是确定的 ,一部分功能是不确定的 . 把确定的功能实现, 不确定的功能抽取出来, 延迟到子类中进行实现。
```

- 案例：

```

```

## 2.18 接口interface

```
如果一个类中的全部方法都是抽象方法, 全部属性都是全局常量, 那么此时可以将这个类定义为一个接口；
接口之间可以继承，接口可以被实现, 且一个类可以实现多个接口；  
接口如果没有被实现,  那么这个接口没有任何的意义。

定义接口的格式: 
    interface 接口名称{
        //全局常量
        //抽象方法
    }

实现接口的格式:
    class 类名 implements 接口1,接口2...接口n{
        //实现抽象方法
    }
    
特别的：
在编写接口中的抽象方法时,可以使用简写格式: 

    格式:  返回值声明 方法名();

    例如:
        编写方法 a
            void a();
        编译器会自动识别为: 
            public abstract void a();
在接口中, 无法定义变量,只能定义全局常量,定义的方式也可以简写:

    格式: 数据类型 常量名 = 初始化值;

    例如:
        定义常量:
            int a = 10;
        编译器会自动识别为:
            public static final int a = 10;
```

问题：抽象类与接口的异同？



## 2.19 匿名对象

```
我们添加对象名称, 是为了创建对象后, 能多次操作这个对象  ,
有时, 我们创建一个对象,  可能只打算使用一次, 那么我们就可以使用匿名对象 !

格式:
        new 类名();

案例:
        new Util().haha(3000);

匿名对象 只能使用一次, 使用完毕后, 会被GC视为垃圾, 进行回收 !
```

## 2.20 内部类
```
内部类, 就是编写在一个类中的成员类 !

格式:
    class 外部类名{
        //成员属性
        //成员方法
        class 内部类名{

        }
    }
```

- 案例

```

```

```
-   缺点: 一个类在设计时, 应只包含特征(属性)和行为(方法) , 内部类的定义 , 打破了原有的定义格式 !
-   优点: 内部类 可以直接访问外部类私有的属性, 可以简化程序的开发, 又能保证程序的封装 !

内部类对象创建的格式:

    外部类名 外部类对象名 = new 外部类名();
    外部类名.内部类名 对象名 = 外部类对象名.new 内部类类名();
案例:
    Outer o = new Outer();
    Outer.Inner i = o.new Inner();
```

```
内部类被编译后, 会生成class文件吗?   如果存在, 文件是如何命名的? 

答:  会生成class文件 命名方式为:  外部类名$内部类名.cl
```

### 2.20.1 静态内部类

```
在内部类前加上static修饰。
格式: 
    class 外部类名{
        //成员属性
        //成员方法
        static class 内部类名{

        }
    }

创建对象的格式:
    外部类名.内部类名 对象名 = new 外部类名.内部类名();
```

### 2.20.2 匿名内部类

```
不存在类名的内部类, 我们称其为匿名内部类, 匿名内部类只可使用一次, 且必须是定义时使用 !

匿名内部类, 必须存在父类或父接口 !!
语法格式:

    new 父类名称(){
        //匿名内部类的代码块
    };
```

```java
案例:
    public class Person{
        private String name;
        private int age;
        public void say(){
            System.out.println("哈哈哈");
        }
    }

    public class Demo{
        public static void main(String[] args){
            Person p = new Person(){
                public void say(){
                    System.out.println("嘿嘿嘿");
                }
            };
            p.say();
        }
    }
```

## 2.21 回调接口

```java
案例:
    public class A {
        /**
         * 求两个数字的和 , 
         * @param num1  求和的第一个数字
         * @param num2  求和的第二个数字
         * @param b 产生结果后, 会将结果传递给B
         */
        public void sum(int num1,int num2,B b) {
            int s = num1+num2;
            b.run(s);
        }
    }

    public interface B {
        void run(int sum);
    }

    public class Demo {
        static B b = new B() { // B的静态内部类
            @Override
            public void run(int sum) {
                System.out.println("run方法执行了 "+sum);
            }
        };
        public static void main(String[] args) {
            A a = new A();
            a.sum(100, 200,b);
            System.out.println("哈哈哈");
        }
    }
```

## 2.22  零碎知识

### 2.22.1 Java中的包

```
Java 所提供的 常见的包
-   java.lang 包 , 是Jre的核心包, JVM启动时会自动加载, 使用此包中的类不需要导包!
-   java.util 包 , 是Java的工具包, 包含了很多的工具类, 是我们后期学习的重点 !
-   java.io   包 , 是输入输出的包, 常用于文件的读写!
-   java.net  包 , 是Java中的网络包, 包含了用于网络编程的所有API . 
-   java.sql  包 , 是操作数据库的包 . 
```



### 2.22.2 Object 对象

```
在java类的体系中, 我们称Object类 为所有类的基类 !  
Object类位于继承关系的顶端 ! 如果一个类定义时没有声明父类, 则默认父类为Object  !
```

### 2.22.3 toString方法 

```
Object类中的toString方法，默认返回的是 : 类名@运算的十六进制hashCode值；
当使用System.out.println打印对象时, 默认打印的是对象的toString方法的返回值；
我们通常会给类 重写 toString方法, 然后让其返回对于当前对象的文字描述信息。
```

- 案例：
```java
public class Person{
    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}
```

### 2.22.4 equals 方法

```
作用：
	判断两个引用所指向的内存空间中的值是否相同
	==  判断基本数据类型的值是否相等；判断两个引用指向是否是同一对象；
编写equals方法原则：
```

```
1. 自反性
x.equals(x); // true

2. 对称性
x.equals(y) == y.equals(x); // true

3. 传递性
if (x.equals(y) && y.equals(z))
    x.equals(z); // true;
4. 一致性
多次调用 equals() 方法结果不变
x.equals(y) == x.equals(y); // true

5. 非空性
对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false
x.equals(null); // false;
```

### 2.22.5 hashCode方法

```
此方法返回一个int类型的数据 , 只需要遵循如下规范即可:

    1.  一致性：同一个对象,属性不更改的情况下, hashCode值应该是一致的；
    2.  两个属性完全相同的对象, hashCode值应该一致；
    3.  hashCode值 ,不是用来判断对象是否相同的依据, hashCode值相同, 对象不一定相等, 
        不过在设计hashCode方法时,我们建议,hashCode值的比较的结果 应与equals比较结果 一致 !

使用：
	一般与equals方法 一起使用!。
```

### 2.22.6 clone方法

```
快速创建一个对象。比new更快，节省了内存测量的过程。
clone方法是Object实现的,我们在使用时,现需要添加克隆标记；
添加标记的方式, 是让一个类实现Cloneable 接口 !
```

```java
案例:
public class Person implements Cloneable{

    private String name;
    private int age;

    @Override
    public Object clone() throws CloneNotSupportedException {
        // TODO Auto-generated method stub
        return super.clone();
    }
}
```

# 2.23 基本数据类型的包装类

```java
byte        java.lang.Byte
short       java.lang.Short
int         java.lang.Integer
long        java.lang.Long
double      java.lang.Double
float       java.lang.Float
char        java.lang.Character
boolean     java.lang.Boolean
```

- **拆箱与装箱**

```
什么是装箱:
    将一个基本数据类型的数据 转换为 包装类对象的过程 !
什么是拆箱:
    将一个包装类的对象 转换为 基本数据类型数据的过程 !
```

- **JDK1.5版本之前, 需手动拆箱与装箱**

```java
装箱操作:
    格式: 
        方式1.    Integer i = new Integer(int值);
        方式2.    Integer i = Integer.valueOf(int值);

拆箱操作:   
    格式:
        int n = Integer对象.intValue();

案例:

    Integer i1 = new Integer(100);
    Integer i2 = Integer.valueOf(100);

    int int1 = i1.intValue();
    int int2 = i2.intValue();
    System.out.println(int1);
    System.out.println(int2);
    System.out.println(int1==int2);

在1.5版本之前, 进行包装类的操作, 特别麻烦 . 例如, 需要将两个integer 进行加法运算, 需如下编写代码:
    Integer i1 = new Integer(100);
    Integer i2 = Integer.valueOf(100);

    int sum = i1.intValue()+i2.intValue();
```

- **JDK1.5版本加入了 自动装箱和拆箱操作**

```
在integer的自动装箱操作中, 加入了一个知名的设计模式, 叫享元设计模式 !  其他的包装类是否有享元？

将-128 - 127的返回的数据, 进行了重复利用 !
```

- **包装类常用属性**

```
MAX_VALUE   :   全局常量, 表示指定包装类的最大值。
MIN_VALUE   :   全局常量, 表示指定包装了的最小值。
```

- **包装类常用方法**

```
将字符串数据, 转换为指定的数据类型 !

-   方式1.    包装类.parseXXX()
        例如:
        int num = Integer.parseInt(String 文本);

-   方式2.    Integer num = new Integer(String 文本);

注意:
    在转换时, 字符串的格式必须是指定类型的,  例如: 不能将"哈哈哈"转换为int类型!  

    转换时数据类型不匹配会抛出错误:
    NumberFormatException   数字格式化异常
```

- **面试题**

```java
Integer i1 = 127;
Integer i2 = 127;
System.out.println(i1==i2); //数据范围-128 - 127 结果为: true
Integer i1 = 128;
Integer i2 = 128;
System.out.println(i1==i2); // false
```

## 2.24 String类

```
-   String的值 一经确定 不可更改。
    在java 8中，String类的内部实现, 是通过 final char[] 来完成的。 又因为数组的长度一经确定无法改变。所以字符串的值一旦确定, 不可更改。
    final保证这个引用变量所引用的地址不会改变，即一直引用同一个对象，但这个String对象str完全可以发生改变。

    在字符串拼接操作时, 系统会舍弃原有字符串 , 开辟新的空间存储拼接的结果, 所以会产生大量的系统垃圾, 建议后期进行开发时, 尽可能少的拼接字符串 !

-   字符串常量池（采用享元设计模式-第二个地方）
    因为我们经常在程序总编写字符串, 且很多时候, 在一个程序中会出现多个相同的字符串 , 官方为了优化这种操作, 加入了字符串常量池 !
    如果程序中使用了一个字符串, 则值会被存储到常量池中, 下次使用时 会自动去常量池中寻找 , 如果存在则重复使用, 不存在则创建新的字符串 并存储到常量池中 !

    注意:  通过new 的到的字符串, 一定是新开辟的内存空间 !

注意: 我们称""引住的部分为字符串字面量 , 一段字符串的字面量,就是一个匿名的String对象 !     
```

在 Java 8 中，String 内部使用 char 数组存储数据。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```

源码解析之为什么说String的之一经确定不可修改？

有人会问：

```java
String str = "abc";
str = "bcd";
System.out.println(str);  //输出bcd
```

输出bcd不是修改了str的值了么，这不就可变了么？

我们知道“abc”与“bcd”为两个字符串常量，分别存储在字符串常量池的两个位置。

又根据源码 final char value[]; 我们知道，字符串由字符数组来存储，final修饰的引用类型变量value不可以更改引用，也就是不可以更改指向，但这个引用所指向的数组内容可以改变，且因为是不可变长数组，故：

```java
final char[] value = {'a', 'b', 'c'};
value[0] = 'd';
System.out.println(value);  //输出dbc
```

且无法向数组内添加或删除新的元素。这样的话指向就发生了改变。

![image-20200728200146574](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728203355.png)

实际上我们要认清一点，我们所说的String字符串并非是指str，而是“abc”与“bcd”，它们一经创建如图：

![image-20200728201543980](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20200728201544.png)

**PS：**jdk1.7 及之后常量池已经从方法区中移了出来，在堆中开辟了一块区域存放运行时常量池，JDK1.8开始，取消了方法区，而使用直接位于内存的元空间。

​		一个字符串常量对应一个匿名的字符串对象，即堆中的value所在。String 类型的str，可以改变其内的引用，但“abc”与“bcd”一经确定，就被固定不可变了，即字符串的值一经确定不可更改。str只是对象变量名。