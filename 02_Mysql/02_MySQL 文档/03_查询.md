

# 查询

## 目标

- 条件查询
- 排序
- 聚合函数
- 分组
- 分页
- 连接查询
- 子查询
- 总结

**准备数据**

## 1. SELECT 语句

- 查询所有字段

```sql
select * from 表名;
例：
select * from t_student;
```

- 查询指定字段

```sql
select 列1,列2,... from 表名;
例:
select name from t_student;
```

- 使用 as 给**字段**起**别名**

```sql
select id as 序号, name as 名字, sex as 性别 from t_student;
```

- 可以通过 as 给**表**起**别名**

```sql
-- 如果是单表查询 可以省略表名
select id, name, sex from t_student;

-- 表名.字段名
select t_student.id,t_student.name,t_student.sex from t_student;

-- 可以通过 as 给表起别名 
select s.id,s.name,s.sex from t_student as s;
```

- 在select后面列前使用`distinct`可以消除重复的行

```sql
select distinct 列1,... from 表名;
例：
select distinct sex from t_student;
```

## 2. 条件查询

使用where子句对表中的数据筛选，结果为true的行会出现在结果集中

- 语法如下：

```sql
select * from 表名 where 条件;
例：
select * from t_student where id=1;
```

- where后面支持多种运算符，进行条件的处理
  - 比较运算符
  - 逻辑运算符
  - 模糊查询
  - 范围查询
  - 空判断

### 比较运算符

- 等于: =
- 大于: >
- 大于等于: >=
- 小于: <
- 小于等于: <=
- 不等于: `!=` 或 `<>`

例1：查询编号大于3的学生

```sql
select * from t_student where id > 3;
```

例2：查询编号不大于4的学生

```sql
select * from t_student where id <= 4;
```

例3：查询姓名不是“殷素素”的学生

```sql
select * from t_student where name != '殷素素';
```

例4：查询没被删除的学生

```sql
select * from t_student where is_delete=0;
```

### 逻辑运算符

- and
- or
- `not`

例5：查询编号大于3的女同学

```sql
select * from t_student where id > 3 and sex=0;
```

例6：查询编号小于4或没被删除的学生

```sql
select * from t_student where id < 4 or is_delete=0;
```

### 模糊查询

- `like` 模糊查询
- `%` 表示任意多个任意字符
- `_` 表示一个任意字符

例7：查询姓张的学生

```sql
select * from t_student where name like '张%';
```

例8：查询姓赵并且"名"是一个字的学生

```sql
select * from t_student where name like '黄_';
```

例9：查询姓 张 或 叫敏 的学生

```sql
select * from t_student where name like '张%' or name like '_敏';
```

### 范围查询

- `in` 表示在一个非连续的范围内

例10：查询编号是1或3或8的学生

```sql
select * from t_student where id in(1,3,8);
```

- `between ... and ...` 表示在一个连续的范围内

例11：查询编号为3至8的学生

```sql
select * from t_student where id between 3 and 8;
```

例12：查询编号是3至8的男生

```sql
select * from t_student where (id between 3 and 8) and sex=1;
```

### 为空判断

- 注意：`null` 与 `''` 是不同的
- 判断空  `is null`

例13：查询没有填写身高的学生

```sql
select * from t_student where height is null;
```

- 判断非空 `is not null`

例14：查询填写了身高的学生

```sql
select * from t_student where height is not null;
```

例15：查询填写了身高的男生

```sql
select * from t_student where height is not null and sex=1;
```

## 3. 字段排序

为了方便查看数据，可以对数据进行排序

### 语法

```sql
select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
```

### 说明

- `orderb by` 排序
- 将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推
- 默认按照列值从小到大排列 `asc`
- `asc` 从小到大排列，即**升序**
- `desc` 从大到小排序，即**降序**

例1：查询未删除的男生信息，按学号降序

```sql
select * from t_student where sex=1 and is_delete=0 order by id desc;
```

例2：查询学生信息 按年龄升序

```sql
SELECT * FROM t_student ORDER BY age ASC;
```

例3：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序

```sql
select * from t_student  order by age desc,height desc;
```

## 4. 聚合函数

为了快速得到**统计数据**，经常会用到如下5个聚合函数

### 总数

- `count(*)` 表示计算总行数，括号中写星与列名，结果是相同的

例1：查询学生总数

```sql
select count(*) from t_student;

-- 统计男生的人数
SELECT COUNT(*) FROM t_student WHERE sex='男';
```

### 最大值

- `max(列)`  表示求此列的最大值

例2：查询女生的编号最大值

```sql
select max(id) from t_student where sex=2;
```

### 最小值

- `min(列)` 表示求此列的最小值

例3：查询未删除的学生最小编号

```sql
select min(id) from t_student where is_delete=0;
```

### 求和

- `sum(列)` 表示求此列的和

例4：查询男生的总年龄

```sql
select sum(age) from t_student where sex=1;

-- 平均年龄
select sum(age)/count(*) from t_student where sex=1;
```

### 平均值

- `avg(列)` 表示求此列的平均值

例5：查询班级女生平均身高

```sql
SELECT AVG(height) FROM t_student WHERE sex='女';
```

## 5. 分组查询

### group by

- `group by` 的含义: 将查询结果按照1个或多个字段进行分组，**字段值相同的为一组**
- `group by` 可用于单个字段分组，也可用于多个字段分组

例1：按性别对学生分组

```sql
select sex from t_student group by sex;
```

根据 `sex` 字段来分组， `sex` 字段的全部值有3个 '男', '女',,'保密'，所以分为了3组 当 `group by` 单独使用时，只**显示出每组的第一条记录**, 所以  `group by` 单独使用时的实际意义不大

### group by + 集合函数

- 通过 **聚合函数** 和 **分组** 来对 **值的集合** 做一些操作

例2：统计不同 **性别分组** 的 **平均年龄**

```sql
select sex,avg(age) from t_student group by sex;
```

例3：统计不同 **性别分组** 的 **人数**

```sql
select sex,count(*) from t_student group by sex;
```

### group by + having

- `having` 条件表达式：用来**分组查询后**指定一些条件来输出查询结果
- `having` 作用和 `where` 一样，但 `having` 只能用于 `group by`

例4：统计不同 性别分组的 **人数大于2人的组**

```sql
select sex,count(*) from t_student group by sex having count(*)>2;
```

### group by + with rollup

- `with rollup` 的作用是：在最后新增一行，来记录当前列里所有记录的总和

```sql
select sex,count(*) from t_student group by sex with rollup;
```

### group by + group_concat()

- `group_concat(字段名)`  可以作为一个输出字段来使用，
- 表示分组之后，根据分组结果，使用 `group_concat()` 来放置每一组的某字段的值的集合

```sql
select sex,group_concat(name) from t_student group by sex;
select sex,group_concat(id) from t_student group by sex;
```



## 6. 分页查询

当数据量过大时，在一页中查看数据是一件非常麻烦的事情

### 语法

```sql
select * from 表名 limit start,count
```

### 说明

- 从 `start+1 ` 开始，获取 `count` 条数据

例1：查询前3行男生信息

```sql
select * from t_student where sex=1 limit 0,3;
```

## 7. 连接查询

当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回

mysql支持三种类型的连接查询，分别为：

### 内连接

- **内连接查询**：查询的结果为**两个表匹配到的数据**

![1537693620651](img\内连接.png)

### 左连接

- **左连接查询**：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充

  ![1537693803998](img\左外连接.png)

### 右连接

- **右连接查询**：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充

  ![1537693739756](img\右外连接.png)



```sql
select * from 表1 inner 或left 或right join 表2 on 表1.列 = 表2.列
```

例1：使用**内连接**查询学生id，学生姓名，班级名称

```sql
select * from t_student as s inner join t_class as c on s.class_id = c.id;
等价于
select * from t_student as s, t_class as c where s.class_id = c.id;
```

例2：使用左连接查询班级表与学生表

```sql
select * from t_student as s left join t_class as c on s.class_id = c.id;
```

例3：使用右连接查询班级表与学生表

```sql
select * from t_student as s right join t_class as c on s.class_id = c.id;
```

例4：查询学生姓名及班级名称

```sql
select s.name,c.name from t_student as s inner join t_class as c on s.class_id = c.id;
```

例5：查询员工编号，员工姓名，领导姓名，领导编号

```sql
CREATE TABLE t_emp (
	eno  int NOT NULL COMMENT '员工编号' ,
	ename  varchar(30) NOT NULL COMMENT '员工姓名' ,
	mgr  int NULL COMMENT '上级领导编号' ,
	PRIMARY KEY (eno)
);
INSERT INTO t_emp(eno, ename, mgr) VALUES ('1', '张三', '8');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('2', '张小一', '1');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('3', '张小二', '1');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('4', '张小三', '1');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('5', '李四', '8');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('6', '李小一', '5');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('7', '李小二', '5');
INSERT INTO t_emp(eno, ename, mgr) VALUES ('8', '李董', NULL);

-- 查询员工的姓名和上级领导的姓名
SELECT
	emp.eno '员工编号',
	emp.ename '员工姓名',
	manager.eno '领导编号',
	manager.ename '领导姓名'
FROM
	t_emp emp,
	t_emp manager
WHERE
	emp.mgr = manager.eno
	
-- 查询所有员工的编号 姓名 上级领导姓名 包含没有上级领导的员工
SELECT
	emp.eno '员工编号',
	emp.ename '员工姓名',
	manager.ename '领导名称'
FROM
	t_emp emp
LEFT JOIN	t_emp manager
ON emp.mgr = manager.eno;
```

## 10. 子查询

### 主查询和子查询

- 在一个 `select` 语句中,嵌入了另外一个 `select` 语句, 那么**被嵌入的** `select` 语句称之为 **子查询语句**
- **子查询** 是嵌入到 **主查询** 中
- **子查询** 是辅助主查询的,要么 **充当条件**, 要么 **充当数据源**
- **子查询** 是可以独立存在的语句,**是一条完整的 `select` 语句**

### 单行子查询

- 子查询返回的结果是单行数据

例1： 查询年龄大于平均年龄的学生信息

```sql
SELECT * FROM t_student WHERE age > (SELECT avg(age) FROM t_student);
```

### 多行子查询

- 子查询返回的结果是多行数据

例2： 查询班级名称是 'JAVAEE01' 和 'JAVAEE02' 两个班级的学生信息

```sql

```

## 总结

### 查询的完整格式 

```sql
SELECT select_expr [,select_expr,...] [      
      FROM tb_name
      [WHERE 条件判断]
      [GROUP BY {col_name | postion} [ASC | DESC], ...] 
      [HAVING WHERE 条件判断]
      [ORDER BY {col_name|expr|postion} [ASC | DESC], ...]
      [ LIMIT {[offset,]rowcount | row_count OFFSET offset}]
]
```

- 完整的select语句

```sql
select distinct *
from 表名
where ....
group by ... having ...
order by ...
limit start,count
```

- 执行顺序为：
  - `from` 表名
  - `where` ....
  - `group by` ...
  - `select distinct` 
  - `having` ...
  - `order by` ...
  - `limit start,count`
- 实际使用中，只是语句中某些部分的组合，而不是全部

